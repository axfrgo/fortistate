# Storyteller Ontogenetic Laws Guide

## üéØ Overview

The **Ontogenetic Laws** for Storyteller ensure that all AI-generated universe pipelines are structurally sound, semantically valid, and operationally robust. These laws enforce invariants that guarantee high-quality, executable workflows.

## üìö Law Categories

### 1. Structural Laws (`STR-*`)
Ensure correct topology and graph structure.

- **STR-001** (Critical): Every pipeline must have at least one BEGIN node
- **STR-002** (Error): BEGIN nodes should not have incoming edges
- **STR-003** (Warning): All non-BEGIN nodes should be reachable from a BEGIN node
- **STR-004** (Error): Every edge must reference existing source and target nodes
- **STR-005** (Warning): Pipeline should not contain cycles (DAG preferred)

### 2. Semantic Laws (`SEM-*`)
Ensure data validity and meaningful content.

- **SEM-001** (Error): All ontogenetic nodes must have an entity identifier
- **SEM-002** (Error): BEGIN nodes must initialize properties
- **SEM-003** (Error): BECOME nodes must define transformation logic
- **SEM-004** (Error): CEASE nodes must define termination condition
- **SEM-005** (Warning): Node positions should not overlap

### 3. Ontogenetic Laws (`ONT-*`)
Enforce lifecycle semantics and operator usage.

- **ONT-001** (Warning): Entity should flow through ontogenetic lifecycle (BEGIN ‚Üí BECOME ‚Üí CEASE)
- **ONT-002** (Info): TRANSCEND nodes should connect to external universes

### 4. Operational Laws (`OPR-*`)
Ensure runtime performance and execution properties.

- **OPR-001** (Warning): Pipeline complexity should be manageable (node count < 50)
- **OPR-002** (Warning): Node branching factor should be reasonable (outDegree < 10)

### 5. Quality Laws (`QLT-*`)
Promote best practices and maintainability.

- **QLT-001** (Info): Nodes should have descriptive narratives
- **QLT-002** (Info): Edges should have descriptive labels

---

## üîç Validation Process

### Automatic Validation
Every pipeline generated by Storyteller is automatically validated:

```typescript
// In StorytellerAgent.execute()
const validationReport = StorytellerLawValidator.validate(pipeline)
console.log(StorytellerLawValidator.generateReport(validationReport))
```

### Validation Report Structure
```typescript
{
  passed: boolean,           // true if no critical/error violations
  score: number,            // 0-100 quality score
  violations: LawViolation[], // All detected violations
  warnings: string[],        // High-level warnings
  metrics: {
    totalLaws: number,
    passed: number,
    failed: number,
    criticalViolations: number,
    errorViolations: number,
    warningViolations: number
  }
}
```

### Scoring System
- **Critical violations**: -20 points each
- **Error violations**: -10 points each
- **Warning violations**: -5 points each
- **Info violations**: -1 point each
- **Maximum score**: 100 (no violations)

---

## üîß Auto-Fix System

The Storyteller can automatically fix common violations:

### Auto-Fixable Violations

1. **SEM-001**: Missing entity identifier
   - Fix: Adds `entity: "${type}_entity"`

2. **SEM-002**: Missing properties in BEGIN
   - Fix: Adds `{ status: 'initialized', created: Date.now() }`

3. **SEM-003**: Missing transform in BECOME
   - Fix: Adds `transform: 'state + delta'`

4. **SEM-004**: Missing condition in CEASE
   - Fix: Adds `condition: 'state.invalid || state.expired'`

### Enabling Auto-Fix
```typescript
const input: StorytellerInput = {
  naturalLanguageStory: "...",
  preferences: {
    autoFix: true  // Enable automatic fixes (default: true)
  }
}
```

### Auto-Fix Flow
```
1. Generate initial pipeline
2. Validate against laws
3. If violations found:
   a. Apply auto-fixes for critical/error violations
   b. Re-validate fixed pipeline
   c. Log improvement
4. Return fixed pipeline with validation report
```

---

## üìä Example Validation Report

```
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   STORYTELLER PIPELINE VALIDATION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Status: ‚úÖ PASSED
Score: 85/100

Metrics:
  ‚Ä¢ Total Laws: 15
  ‚Ä¢ Passed: 12
  ‚Ä¢ Failed: 3

Violations by Severity:
  ‚Ä¢ Critical: 0
  ‚Ä¢ Errors: 0
  ‚Ä¢ Warnings: 3

Violations:
  1. [WARNING] SEM-005: Nodes "node-2" and "node-3" are overlapping
     ‚Üí Adjust node positions to prevent visual overlap
  2. [WARNING] ONT-001: Entity "player" only has BEGIN - consider adding BECOME or CEASE
     ‚Üí Add transformation (BECOME) or termination (CEASE) logic
  3. [INFO] QLT-001: Node "node-4" has no narrative description
     ‚Üí Add a human-readable narrative for better understanding

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```

---

## üéì Best Practices

### Writing Compliant Pipelines

#### ‚úÖ DO:
```typescript
// Complete BEGIN node
{
  type: 'begin',
  data: {
    entity: 'user_account',
    properties: { status: 'active', balance: 0 },
    narrative: 'Initialize user account'
  }
}

// Complete BECOME node
{
  type: 'become',
  data: {
    entity: 'user_account',
    transform: 'balance + amount',
    narrative: 'Process deposit'
  }
}

// Complete CEASE node
{
  type: 'cease',
  data: {
    entity: 'user_account',
    condition: 'balance < 0 || suspended',
    narrative: 'Terminate account'
  }
}
```

#### ‚ùå DON'T:
```typescript
// Missing entity
{
  type: 'begin',
  data: { status: 'active' }  // ‚ùå No entity
}

// Missing transform
{
  type: 'become',
  data: { entity: 'account' }  // ‚ùå No transform
}

// BEGIN with incoming edge
edges: [
  { source: 'node-1', target: 'begin-node' }  // ‚ùå BEGIN shouldn't have incoming edges
]
```

---

## üß™ Testing Your Pipeline

### Manual Validation
```typescript
import { StorytellerLawValidator } from './storyteller-laws'

const pipeline = { /* your pipeline */ }
const report = StorytellerLawValidator.validate(pipeline)

console.log(`Passed: ${report.passed}`)
console.log(`Score: ${report.score}/100`)
console.log(`Violations: ${report.violations.length}`)
```

### Quality Threshold Check
```typescript
import { meetsQualityThreshold } from './storyteller-laws'

if (!meetsQualityThreshold(report, 80)) {
  console.warn('Pipeline does not meet 80% quality threshold')
}
```

### Get Violations by Category
```typescript
const byCategory = StorytellerLawValidator.getViolationsByCategory(report)

byCategory.forEach((violations, category) => {
  console.log(`${category}: ${violations.length} violations`)
})
```

---

## üî¨ Advanced Usage

### Custom Law Implementation

Each law follows this interface:
```typescript
interface OntogeneticLaw {
  id: string                    // Unique identifier (e.g., "STR-001")
  category: LawCategory         // structural | semantic | ontogenetic | operational | quality
  severity: LawSeverity         // critical | error | warning | info
  description: string           // Human-readable description
  invariant: string             // Formal logic notation
  validate: (pipeline) => LawViolation[]
}
```

### Adding Custom Laws
```typescript
import { STORYTELLER_LAWS } from './storyteller-laws'

STORYTELLER_LAWS.push({
  id: 'CUSTOM-001',
  category: 'semantic',
  severity: 'warning',
  description: 'Custom validation rule',
  invariant: 'forall(node => customCheck(node))',
  validate: (pipeline) => {
    const violations: LawViolation[] = []
    // Your validation logic
    return violations
  }
})
```

---

## üìà Integration with Canvas

### Agent Insights Display
The Canvas automatically displays validation results in the Agent Insights panel:

```typescript
// In Canvas.tsx
const storytellerOutput = await storytellerAgent.execute(input)

if (storytellerOutput.validation) {
  const { passed, score, violations } = storytellerOutput.validation
  
  console.log(`‚úÖ Validation: ${passed ? 'PASSED' : 'FAILED'} (${score}/100)`)
  
  violations.forEach(v => {
    console.log(`  [${v.severity}] ${v.message}`)
  })
}
```

### User-Facing Messages
- **Passed (score ‚â• 90)**: "‚ú® High-quality pipeline generated!"
- **Passed (score 70-89)**: "‚úÖ Pipeline validated with minor suggestions"
- **Failed (errors)**: "‚ö†Ô∏è Pipeline has issues that may affect execution"
- **Failed (critical)**: "‚ùå Pipeline is invalid and cannot be used"

---

## üöÄ Performance

### Validation Performance
- **Average time**: < 10ms for typical pipelines (5-20 nodes)
- **Complexity**: O(N + E) where N = nodes, E = edges
- **Memory**: Minimal overhead, suitable for real-time validation

### Optimization Tips
1. Run validation asynchronously for large pipelines (50+ nodes)
2. Cache validation results if pipeline hasn't changed
3. Use `meetsQualityThreshold()` for quick pass/fail checks

---

## üîó Related Documentation

- [Ontogenetic AWS Guide](./ONTOGENETIC_AWS_GUIDE.md) - For Custodian fix management
- [Agent Types Reference](./packages/visual-studio/src/ai/agentTypes.ts) - Type definitions
- [Storyteller Agent](./packages/visual-studio/src/ai/agentRuntime.ts) - Implementation

---

## üìù Change Log

### v1.0.0 (Current)
- ‚úÖ 15 ontogenetic laws implemented
- ‚úÖ Automatic validation in Storyteller agent
- ‚úÖ Auto-fix for 4 common violations
- ‚úÖ Comprehensive scoring system (0-100)
- ‚úÖ Integration with Canvas UI
- ‚úÖ Full documentation

### Future Enhancements
- [ ] Law profiles (strict, balanced, lenient)
- [ ] Custom law definitions via config
- [ ] Integration with JIT compiler for runtime validation
- [ ] Visual law violation overlay in Canvas
- [ ] Export validation reports to PDF/JSON

---

## üí° FAQ

**Q: Can I disable validation?**  
A: No, validation always runs but you can ignore warnings/info violations. Critical and error violations should be addressed.

**Q: What happens if my pipeline fails validation?**  
A: The pipeline is still returned, but includes a validation report. Auto-fix may correct some issues automatically.

**Q: Can I customize the scoring system?**  
A: Currently no, but you can implement your own scoring logic using the violation data.

**Q: Are circular workflows supported?**  
A: Law STR-005 warns against cycles, but they're allowed. DAGs are preferred for simplicity.

**Q: How do I know which node is causing a violation?**  
A: Each violation includes `nodeId` or `edgeId` when applicable.

---

## üìû Support

For questions or issues:
1. Check existing laws in `src/ai/storyteller-laws.ts`
2. Review validation output in browser console
3. Consult Agent Insights panel in Canvas UI
4. File an issue with validation report attached

---

**Built with ontogenetic precision for the Fortistate ecosystem** üåå

/**
 * Cosmogenesis: Universe Manager
 *
 * Orchestrates multiple causal stores as a unified universe with:
 * - Shared substrate (laws of physics)
 * - Coordinated event processing
 * - Lifecycle management (spawn, pause, resume, destroy)
 * - Cross-store reactions and dependencies
 * - Telemetry aggregation
 */

import type { CausalStore } from '../temporal/causalStore.js';
import { createCausalStore } from '../temporal/causalStore.js';
import type { Store } from '../storeFactory.js';
import { createStore } from '../storeFactory.js';
import type { Substrate } from '../algebra/substrate.js';
import type { UniverseLaw } from '../algebra/substrate.js';
import { ConstraintAuditor } from './auditor.js';
import type { LawTelemetry } from './telemetry.js';
import type { UniverseId, ObserverId } from '../temporal/causalEvent.js';

export interface UniverseConfig {
  /** Unique identifier for this universe */
  id: UniverseId;
  
  /** Human-readable name */
  name?: string;
  
  /** Substrate defining the laws of physics */
  substrate: Substrate;
  
  /** Initial stores to create (key -> initial value) */
  initialStores?: Map<string, any>;
  
  /** Laws to enforce (overrides substrate.laws if provided) */
  laws?: Map<string, UniverseLaw<any>[]>;
  
  /** Enable automatic constraint repair */
  autoRepair?: boolean;
  
  /** Enable law reactions (cross-store effects) */
  applyReactions?: boolean;
  
  /** Observer ID for events generated by this universe */
  observerId?: ObserverId;
  
  /** Custom telemetry sink */
  telemetrySink?: (entry: LawTelemetry) => void;
  
  /** Metadata to attach to all events */
  metadata?: Record<string, unknown>;
}

export type UniverseState = 'initializing' | 'running' | 'paused' | 'destroyed';

export interface UniverseSnapshot {
  id: UniverseId;
  name?: string;
  state: UniverseState;
  storeCount: number;
  stores: Map<string, any>;
  metadata: Record<string, unknown>;
  createdAt: number;
  lastEventAt?: number;
  eventCount: number;
}

export class UniverseManager {
  readonly id: UniverseId;
  readonly name?: string;
  readonly substrate: Substrate;
  readonly observerId?: ObserverId;
  
  private readonly stores = new Map<string, CausalStore<any>>();
  private readonly auditor: ConstraintAuditor;
  private readonly metadata: Record<string, unknown>;
  private readonly createdAt: number;
  
  private state: UniverseState = 'initializing';
  private eventCount = 0;
  private lastEventAt?: number;

  constructor(config: UniverseConfig) {
    this.id = config.id;
    this.name = config.name;
    this.substrate = config.substrate;
    this.observerId = config.observerId;
    this.metadata = config.metadata ?? {};
    this.createdAt = Date.now();

    // Create auditor for constraint enforcement
    this.auditor = new ConstraintAuditor({
      substrate: this.substrate,
      stores: this.stores,
      laws: config.laws,
      autoRepair: config.autoRepair ?? true,
      applyReactions: config.applyReactions ?? true,
      telemetrySink: config.telemetrySink,
    });

    // Initialize stores
    if (config.initialStores) {
      for (const [key, initial] of config.initialStores.entries()) {
        this.createStore(key, initial);
      }
    }
  }

  /**
   * Start the universe (enable constraint enforcement)
   */
  start(): void {
    if (this.state === 'destroyed') {
      throw new Error(`Cannot start destroyed universe ${this.id}`);
    }
    
    this.state = 'running';
    this.auditor.start();
  }

  /**
   * Pause the universe (disable constraint enforcement)
   */
  pause(): void {
    if (this.state !== 'running') return;
    
    this.state = 'paused';
    this.auditor.stop();
  }

  /**
   * Resume a paused universe
   */
  resume(): void {
    if (this.state !== 'paused') return;
    
    this.state = 'running';
    this.auditor.start();
  }

  /**
   * Destroy the universe (cleanup all resources)
   */
  destroy(): void {
    this.auditor.stop();
    this.stores.clear();
    this.state = 'destroyed';
  }

  /**
   * Create a new causal store in this universe
   */
  createStore<T>(key: string, initial: T): CausalStore<T> {
    if (this.stores.has(key)) {
      throw new Error(`Store ${key} already exists in universe ${this.id}`);
    }

    // Create base store with key and initial value
    const baseStore: Store<T> = {
      get: () => this.stores.get(key)?.get() ?? initial,
      set: (v: T) => {},
      subscribe: (fn: (s: T) => void) => () => {},
      reset: () => {},
    };
    
    // Initialize state
    let state = initial;
    const subs = new Set<(s: T) => void>();
    
    baseStore.get = () => state;
    baseStore.set = (v: T) => {
      state = v;
      subs.forEach(fn => fn(state));
    };
    baseStore.subscribe = (fn: (s: T) => void) => {
      subs.add(fn);
      return () => subs.delete(fn);
    };
    baseStore.reset = () => {
      state = initial;
      subs.forEach(fn => fn(state));
    };
    
    // Wrap with causal tracking
    const store = createCausalStore<T>(baseStore, key, {
      initialUniverse: this.id,
      observerId: this.observerId,
    });

    this.stores.set(key, store);

    // Subscribe to track events
    store.subscribe(() => {
      this.eventCount++;
      this.lastEventAt = Date.now();
    });

    // If universe is already running, tell auditor to watch this store
    if (this.state === 'running') {
      this.auditor.stop();
      this.auditor.start();
    }

    return store;
  }

  /**
   * Get a store by key
   */
  getStore<T = any>(key: string): CausalStore<T> | undefined {
    return this.stores.get(key) as CausalStore<T> | undefined;
  }

  /**
   * Check if a store exists
   */
  hasStore(key: string): boolean {
    return this.stores.has(key);
  }

  /**
   * Remove a store from the universe
   */
  removeStore(key: string): boolean {
    const store = this.stores.get(key);
    if (!store) return false;

    this.stores.delete(key);

    // Restart auditor to update watched stores
    if (this.state === 'running') {
      this.auditor.stop();
      this.auditor.start();
    }

    return true;
  }

  /**
   * Get all store keys
   */
  getStoreKeys(): string[] {
    return Array.from(this.stores.keys());
  }

  /**
   * Get current universe state
   */
  getState(): UniverseState {
    return this.state;
  }

  /**
   * Get universe statistics
   */
  getStats() {
    return {
      id: this.id,
      name: this.name,
      state: this.state,
      storeCount: this.stores.size,
      eventCount: this.eventCount,
      createdAt: this.createdAt,
      lastEventAt: this.lastEventAt,
      uptime: Date.now() - this.createdAt,
    };
  }

  /**
   * Create a snapshot of the current universe state
   */
  snapshot(): UniverseSnapshot {
    const stores = new Map<string, any>();
    for (const [key, store] of this.stores.entries()) {
      stores.set(key, store.get());
    }

    return {
      id: this.id,
      name: this.name,
      state: this.state,
      storeCount: this.stores.size,
      stores,
      metadata: { ...this.metadata },
      createdAt: this.createdAt,
      lastEventAt: this.lastEventAt,
      eventCount: this.eventCount,
    };
  }

  /**
   * Restore universe from a snapshot
   */
  restore(snapshot: UniverseSnapshot): void {
    if (snapshot.id !== this.id) {
      throw new Error(`Cannot restore snapshot from universe ${snapshot.id} into ${this.id}`);
    }

    // Pause to avoid constraint violations during restore
    const wasRunning = this.state === 'running';
    if (wasRunning) this.pause();

    // Update all stores
    for (const [key, value] of snapshot.stores.entries()) {
      const store = this.stores.get(key);
      if (store) {
        store.set(value);
      } else {
        this.createStore(key, value);
      }
    }

    // Remove stores not in snapshot
    for (const key of this.stores.keys()) {
      if (!snapshot.stores.has(key)) {
        this.removeStore(key);
      }
    }

    // Resume if was running
    if (wasRunning) this.resume();
  }

  /**
   * Get telemetry events from the auditor
   */
  getTelemetry(): LawTelemetry[] {
    return this.auditor.getTelemetry();
  }

  /**
   * Run a full constraint scan across all stores
   */
  async scan(): Promise<void> {
    await this.auditor.scan();
  }

  /**
   * Fork this universe into a new universe with the current state
   */
  fork(newId: UniverseId, config?: Partial<UniverseConfig>): UniverseManager {
    const snapshot = this.snapshot();
    
    const forkedUniverse = new UniverseManager({
      id: newId,
      name: config?.name ?? `${this.name} (fork)`,
      substrate: this.substrate,
      initialStores: snapshot.stores,
      laws: config?.laws,
      autoRepair: config?.autoRepair,
      applyReactions: config?.applyReactions,
      observerId: config?.observerId ?? this.observerId,
      telemetrySink: config?.telemetrySink,
      metadata: { ...this.metadata, ...config?.metadata, forkedFrom: this.id },
    });

    return forkedUniverse;
  }

  /**
   * Clone this universe (same as fork but preserves the same ID pattern)
   */
  clone(suffix: string = 'clone'): UniverseManager {
    const cloneId = `${this.id}-${suffix}` as UniverseId;
    return this.fork(cloneId);
  }
}

/**
 * Helper to create and start a universe
 */
export function createUniverse(config: UniverseConfig): UniverseManager {
  const universe = new UniverseManager(config);
  universe.start();
  return universe;
}

/**
 * Multiverse coordinator for managing multiple universes
 */
export class Multiverse {
  private readonly universes = new Map<UniverseId, UniverseManager>();

  /**
   * Add a universe to the multiverse
   */
  add(universe: UniverseManager): void {
    if (this.universes.has(universe.id)) {
      throw new Error(`Universe ${universe.id} already exists in multiverse`);
    }
    this.universes.set(universe.id, universe);
  }

  /**
   * Remove a universe from the multiverse
   */
  remove(id: UniverseId): boolean {
    const universe = this.universes.get(id);
    if (!universe) return false;
    
    universe.destroy();
    this.universes.delete(id);
    return true;
  }

  /**
   * Get a universe by ID
   */
  get(id: UniverseId): UniverseManager | undefined {
    return this.universes.get(id);
  }

  /**
   * Get all universe IDs
   */
  getIds(): UniverseId[] {
    return Array.from(this.universes.keys());
  }

  /**
   * Get all universes
   */
  getAll(): UniverseManager[] {
    return Array.from(this.universes.values());
  }

  /**
   * Pause all universes
   */
  pauseAll(): void {
    for (const universe of this.universes.values()) {
      universe.pause();
    }
  }

  /**
   * Resume all universes
   */
  resumeAll(): void {
    for (const universe of this.universes.values()) {
      universe.resume();
    }
  }

  /**
   * Destroy all universes
   */
  destroyAll(): void {
    for (const universe of this.universes.values()) {
      universe.destroy();
    }
    this.universes.clear();
  }

  /**
   * Get aggregate statistics across all universes
   */
  getStats() {
    const stats = {
      universeCount: this.universes.size,
      totalStores: 0,
      totalEvents: 0,
      byState: {
        initializing: 0,
        running: 0,
        paused: 0,
        destroyed: 0,
      },
    };

    for (const universe of this.universes.values()) {
      const universeStats = universe.getStats();
      stats.totalStores += universeStats.storeCount;
      stats.totalEvents += universeStats.eventCount;
      stats.byState[universeStats.state]++;
    }

    return stats;
  }
}
